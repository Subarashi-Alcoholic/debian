# Отчет по лабораторной работе №3 Посметюк А.И. ИС-21

## **1.  Оптимизация конфигурации PostgreSQL**

sudo nano /etc/postgresql/12/main/postgresql.conf

- shared_buffers = 512MB

![](vertopal_036234df9d974265a20f3b802af504dc/media/image1.png)

Основной кэш Postgresql, рекомендуется выделять 15--25% от оперативной
памяти для выделенных серверов, поэтому установим 512 MB (25% от 4 GB).

- work_mem = 4MB

![](vertopal_036234df9d974265a20f3b802af504dc/media/image2.png)

Определяет объём памяти, выделяемый для операций сортировки и
хэш-объединения в рамках одного запроса. Значение задаётся для каждого
отдельного процесса, поэтому его не стоит ставить слишком высоким,
обычно 4--8 MB -- поставим 4 MB.

- maintenance_work_mem = 64MB

![](vertopal_036234df9d974265a20f3b802af504dc/media/image3.png)

Память, используемая для административных операций, данные операции
выполняются редко, поэтому можно выделить больше памяти -- обычно
10--20% от оперативной памяти, например, 64 MB.

- effective_cache_size = 2GB

![](vertopal_036234df9d974265a20f3b802af504dc/media/image4.png)

Это оценка объёма памяти, доступной для кэширования на уровне
операционной системы, и служит подсказкой для оптимизатора запросов.
Рекомендуется устанавливать значение около 50--75% от общей оперативной
памяти. Для нашей машины можно задать 2 GB.

- sudo systemctl restart postgresql

![](vertopal_036234df9d974265a20f3b802af504dc/media/image5.png)

![](vertopal_036234df9d974265a20f3b802af504dc/media/image6.png)

## **2.  Создание и анализ индексов**

Создаем таблицу и заполняем данными, а именно числами от 0 до 1млн

![](vertopal_036234df9d974265a20f3b802af504dc/media/image7.png)

Выполняем EXPLAIN ANALYZE до создания индекса и ищем 500 000

![](vertopal_036234df9d974265a20f3b802af504dc/media/image8.png)

Теперь создаем INDEX и снова ищем 500 000

![](vertopal_036234df9d974265a20f3b802af504dc/media/image9.png)

И видим, что время поиска значительно сократилось, время выполнения
запроса (execution time) изменилось с 135с до всего 1.9с

3.  Хранимые функции

Создаем код на pl/pySQL

![](vertopal_036234df9d974265a20f3b802af504dc/media/image10.png)

![](vertopal_036234df9d974265a20f3b802af504dc/media/image11.png)

CREATE OR REPLACE FUNCTION znachenie_otricatelnoe_ili_net(input_value
INTEGER)

Определяем или пересоздаём функцию с именем add_value_if_positive,
которая принимает один параметр input_value типа INTEGER.

RETURNS TEXT

Функция будет возвращать текстовое сообщение.

LANGUAGE plpgsql

Указываем язык реализации функции --- PL/pgSQL.

BEGIN ... END

Тело функции. Здесь описана логика проверки и вставки.

IF input_value \< 0 THEN ... ELSE ... END IF;

Условие: если число отрицательное --- возвращаем сообщение об ошибке;
иначе вставляем запись в таблицу.

INSERT INTO test_data(number) VALUES (input_value);

Вставка значения в столбец number таблицы test_data.

RETURN \'...\';

Возвращаем сообщение об операции.

Загружаем эту функцию внутри базы данных и проверяем

![](vertopal_036234df9d974265a20f3b802af504dc/media/image12.png)

Проверим, действительно ли есть запись\
![](vertopal_036234df9d974265a20f3b802af504dc/media/image13.png)

4.  **Триггеры**

Создаем новую таблицу

![](vertopal_036234df9d974265a20f3b802af504dc/media/image14.png)

Создаем скрипт триггер для
цен![](vertopal_036234df9d974265a20f3b802af504dc/media/image15.png)

RETURNS TRIGGER: функция возвращает тип TRIGGER, который необходим для
функций, связанных с триггерами.

IF NEW.price \< 0: мы проверяем новое значение цены, которое пытаются
вставить или обновить.

RAISE EXCEPTION: выбрасываем ошибку с текстом. % подставляет значение
NEW.price.

Создаем функцию в бд и сохраняем как триггер чтобы он выполнялся

![](vertopal_036234df9d974265a20f3b802af504dc/media/image16.png)

Создадим запись

![](vertopal_036234df9d974265a20f3b802af504dc/media/image17.png)

И запись с отрицательным числом

![](vertopal_036234df9d974265a20f3b802af504dc/media/image18.png)

##**5.  Автоматическая очистка и статистика (VACUUM, ANALYZE)**

Проверяем включен ли он\
![](vertopal_036234df9d974265a20f3b802af504dc/media/image19.png)

Проверяем настройки

![](vertopal_036234df9d974265a20f3b802af504dc/media/image20.png)

autovacuum_naptime: Интервал между проверками базы данных на
необходимость запуска autovacuum.

autovacuum_vacuum_scale_factor: Доля «мёртвых» строк в таблице, при
достижении которой запускается вакуум.

autovacuum_analyze_scale_factor: Доля изменений в таблице, после которой
будет выполнен ANALYZE для обновления статистики.

VACUUM -- Удаляет «мёртвые» строки, освобождая место и предотвращая
разрастание таблицы.

ANALYZE -- Собирает и обновляет статистику о содержимом таблицы, которую
использует оптимизатор запросов для составления плана выполнения.

![](vertopal_036234df9d974265a20f3b802af504dc/media/image21.png)

Обычно он ничего не выводит, но можно использовать более расширенный
вывод

![](vertopal_036234df9d974265a20f3b802af504dc/media/image22.png)

![](vertopal_036234df9d974265a20f3b802af504dc/media/image23.png)

**pg_stat_user_tables:** содержит статистику по таблицам, принадлежащим
пользователю. Здесь можно увидеть число вызовов autovacuum, manual
vacuum, а также количество строк, обновлений и удаления.

![](vertopal_036234df9d974265a20f3b802af504dc/media/image24.png)

**pg_stat_all_indexes:** содержит статистику по индексам, такую как
число сканирований по индексам.

![](vertopal_036234df9d974265a20f3b802af504dc/media/image25.png)

###Другие полезные

**pg_stat_database:** Статистика по базе данных (например, число
autovacuum-вызовов для базы данных в целом).

![](vertopal_036234df9d974265a20f3b802af504dc/media/image26.png)

- datname --- имя базы данных.

- numbackends --- количество клиентских подключений к базе данных.

- xact_commit и xact_rollback --- число подтверждённых и откатанных
транзакций соответственно.

- blks_read и blks_hit --- сколько блоков было физически считано с диска и
сколько блоков нашлось в буферном кэше (cache hits).
