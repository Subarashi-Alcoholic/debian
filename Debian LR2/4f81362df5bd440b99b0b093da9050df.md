# Отчет по лабораторной работе №2 Посметюк А.И. ИС-21
## **1. Утилиты резервного копирования**

**pg_dump** создает резервную копию, которая представляет собой набор SQL-команд. При использовании этой утилиты копируются:
- Структура базы данных: определения таблиц, индексов, представлений, триггеров, последовательностей и других объектов.
- Данные таблиц: команды для вставки данных, чтобы восстановить их в том виде, в котором они были на момент дампа.

`pg_dump -U username -d dbname -f backup.sql`

**Сценарии применения pg_dump:**
- Миграция данных между разными серверами или версиями PostgreSQL.
- Выборочное резервное копирование отдельных схем или таблиц.
- Перенос базы данных на другую платформу, где требуется логическая копия в виде SQL-скрипта.
- Восстановление базы данных в случае повреждения, когда можно последовательно выполнить скрипт для восстановления структуры и данных.

**pg_basebackup** выполняет копирование на уровне файловой системы. При его использовании копируются:
- Файлы данных PostgreSQL, в том числе файлы таблиц, индексов и другие системные файлы.
- Файлы журналов транзакций (WAL-файлы), необходимые для поддержания целостности данных.
- Табличные пространства и метаданные, расположенные в файловой структуре сервера.

`pg_basebackup -U username -D /backup/location -Ft -z -P`

**Сценарии применения pg_basebackup:**
- Создание полной копии кластера базы данных для быстрой и точной реставрации.
- Настройка репликации или standby-сервера, где необходима физическая копия данных.
- Резервное копирование больших баз данных, где логическая копия может быть неэффективной или слишком медленной.
- Восстановление системы в случае серьезных сбоев, когда требуется вернуть весь кластер в исходное состояние.

## **2. Создание резервной копии**

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image1.png)

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image2.png)

`pg_dump -U pai -d db1 -Fc -f db1_backup.dump`

- -Fc (custom format): создает резервную копию в специальном бинарном формате, который поддерживает сжатие и позволяет восстанавливать отдельные объекты.

- -f db1_backup.dump: сохраняет резервную копию в файл db1_backup.dump.

- -Ft (tar format): cоздает резервную копию в формате tar-архива.

- -Fp (plain text format): cоздает резервную копию в виде SQL-скрипта.

- -Z (сжатие): позволяет указать уровень сжатия (от 0 до 9) для форматов -Fc и -Ft.

- -v (verbose): выводит подробную информацию о процессе создания резервной копии.

- -U (username):указывает пользователя для подключения к базе данных.

- -d (database): указывает имя базы данных, для которой создается резервная копия.

## **3. Частичное (выборочное) резервное копирование**

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image3.png)

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image4.png)

- **n** - для схем

- **t** - для таблиц

**Объяснение:** при полном резервном копировании **pg_dump** выгружает все объекты базы 
(включая все схемы, таблицы, функции и т.д.) вместе с данными, что 
позволяет в дальнейшем полностью восстановить базу в исходном состоянии.  
Когда же делается дамп только определённой схемы или отдельных таблиц, в 
резервную копию попадают лишь указанные объекты.

## **4. Восстановление из резервной копии**

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image5.png)

**Восстановление из дампа**  
   Команда `pg_restore -U postgres -d db1_new -v db1_backup.dump`:
   - Подключается к базе данных `db1_new`.
   - Читает данные из файла `db1_backup.dump`.
   - По шагам воссоздаёт объекты (схемы, таблицы, индексы, ключи) и заполняет их данными, согласно информации в дампе.
   - Ключ `-v` (verbose) позволяет увидеть детальный вывод: какие схемы и таблицы создаются, какие данные загружаются, какие ограничения накладываются.

## **5. Автоматизация бэкапов с помощью cron**

Ротация резервных копий - это процесс управления «старыми»
дампами: хранится лишь необходимое количество (или необходимый период по
дням/неделям/месяцам), а слишком старые дампы удаляются.

Создаем директорию для бэкапа

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image6.png)

Редактируем crontab -e

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image7.png)

**Разбор команды (первая строка) :**

- **\*/1 \* \* \* \*** -задание запускается каждую минуту.

- **bash -c \'...\'** -позволяет выполнить всю команду в оболочке
    Bash (так можно использовать вложенные команды, как \$(date ...)).

- **/usr/bin/pg_dump -U postgres db1** -команда для создания дампа
    базы данных db1 с пользователем postgres.\
    Для указания другого хоста или порта, можно добавить
    параметры -h и -p.

**Разбор команды (вторая строка):**

- **\*/2 \* \* \* \*** -задание запускается каждые 2 минуты.

- **find /var/backups/pg -name \"\*.dump\" -type f -mmin +1** -ищет
    файлы с расширением .dump, тип которых -обычный файл, и которые
    были изменены более 1 минуты назад.\
    Здесь используется -mmin +1 для демонстрации (в реальной системе
    можно использовать, например, -mmin +1440 для файлов старше одного
    дня или -mtime +7 для 7 дней).

- **-exec rm -f {} \\;** -для каждого найденного файла выполняется
    команда rm -f (удаление без запроса подтверждения).

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image8.png)

## **6. Мониторинг состояния системы**

**top** - это интерактивная консольная утилита для мониторинга
процессов и состояния системы в режиме реального времени.

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image9.png)

**Первая строка**

- **10:33:28**  
  Текущее время на системе.

- **up 4:24**  
  Система работает непрерывно 4 часа 24 минуты (uptime).

- **4 users**  
  Количество пользователей, у которых есть активные сессии (терминалы/tty).

- **load average: 0.95, 0.57, 0.63**  
  Средняя загрузка системы за последние 1, 5 и 15 минут.  
  - Показатель «load average» отражает, сколько процессов в среднем ожидают выполнения.  
  - Если у вас 1 ядро и load average > 1, это означает, что очередь процессов на CPU растёт. На многопроцессорных (многоядерных) системах нужно учитывать общее количество ядер: например, для 4 ядер «нормальный» уровень загрузки может быть до 4.0.

**Вторая строка**

- **222 total**  
  Всего процессов в системе (с учётом зомби-процессов).

- **1 running**  
  Количество процессов, которые в данный момент выполняются (на CPU).

- **218 sleeping**  
  Процессы, находящиеся в состоянии ожидания (спят).

- **3 stopped**  
  Процессы, остановленные сигналом (обычно SIGSTOP) или находящиеся в режиме отладки.

- **0 zombie**  
  «Зомби»-процессы (это процесс, который уже завершил своё выполнение (вызвал exit()), но всё ещё числится в таблице процессов, поскольку родительский процесс не забрал (не «выполнил») код завершения дочернего процесса с помощью системного вызова wait()).

**Третья строка**

Расшифровка полей (в процентах от всего CPU-времени):

- **us (user)**  
  Время, затрачиваемое на пользовательские процессы (непривилегированные).

- **sy (system)**  
  Время, затрачиваемое на процессы ядра (системные вызовы).

- **ni (nice)**  
  Время на процессы с изменённым приоритетом (через nice/renice).

- **id (idle)**  
  Процент бездействия (простояв CPU). Чем выше этот показатель, тем меньше CPU нагружен.

- **wa (iowait)**  
  Время ожидания ввода-вывода (например, когда процесс ждёт чтения/записи на диск).

- **hi (hardware interrupts)**  
  Время, затрачиваемое на аппаратные прерывания.

- **si (software interrupts)**  
  Время, затрачиваемое на программные (софт) прерывания.

- **st (steal)**  
  Время «украденное» виртуализатором (актуально при работе в виртуальной машине, когда гипервизор переключает CPU на другие задачи).

**Четвертая (объём физической оперативной памяти) и пятая (объём пространства подкачки) строка**

- **1001.1 total**  
  Всего доступно оперативной памяти (MiB — мегибайты, примерно 1.05 МБ).

- **654.3 free**  
  Свободная память.

- **446.2 used**  
  Память, используемая процессами и ядром.

- **442.0 buff/cache**  
  Память, занятая буферами/кешем (файловая система, дисковый кеш и т.д.).

- **Swap**  
  Объём и использование подкачки (swap). В примере 0.0 total, значит подкачка отключена или её нет.

**Таблица процессов**

Основная таблица под сводкой содержит список процессов, отсортированных
(по умолчанию) по убыванию загрузки CPU. Каждый столбец имеет своё
значение:

| **Столбец** | **Название**  | **Описание**                                                                                                                                              |
|-------------|---------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| PID         | Process ID    | Идентификатор процесса.                                                                                                                                   |
| USER        | User name     | Пользователь, от имени которого запущен процесс.                                                                                                        |
| PR          | Priority      | Приоритет процесса (число, используемое планировщиком).                                                                                                  |
| NI          | Nice value    | «Найс»-приоритет. Чем выше число, тем «добрее» процесс и тем ниже его приоритет. Чем ниже число (может быть отрицательным), тем выше приоритет.           |
| VIRT        | Virtual       | Объём виртуальной памяти, используемой процессом (включая библиотеки, файлы на диске, т. д.).                                                              |
| RES         | Resident      | Объём резидентной памяти (RAM), фактически занятой процессом.                                                                                             |
| SHR         | Shared        | Количество разделяемой памяти (например, разделяемые библиотеки).                                                                                         |
| S           | State         | Текущее состояние процесса (R — running, S — sleeping, D — uninterruptible sleep, T — stopped, Z — zombie).                                               |
| %CPU        | CPU usage     | Доля (в %) от одного CPU, потребляемая процессом.                                                                                                         |
| %MEM        | Mem usage     | Доля (в %) от общей физической памяти, потребляемая процессом.                                                                                            |
| TIME+       | CPU Time      | Общее процессорное время, которое процесс успел «съесть» с момента запуска.                                                                               |
| COMMAND     | Command       | Имя команды (или путь к исполняемому файлу).                                                                                                                |


## **7. Мониторинг PostgreSQL**

**pg_stat_activity** - текущее состояние всех подключений и выполняемых
запросов.

**pg_stat_database** - статистика по всем базам данных: количество
запросов, ошибки, объемы чтения/записи и т. д.

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image10.png)

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image11.png)

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image12.png)

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image13.png)

- **datid / datname**  
  Идентификатор и имя базы данных, к которой подключён бэкенд.

- **pid** (в старых версиях - **procpid**)  
  PID (идентификатор процесса) на сервере, соответствующий данному соединению. Используется, в том числе, для завершения (kill) зависших запросов с помощью функции pg_terminate_backend().

- **usesysid / usename**  
  Идентификатор и имя пользователя, от чьего имени идёт соединение.

- **application_name**  
  Имя приложения, передаваемое клиентом при подключении (например, psql, pgAdmin, JDBC-приложение).

- **client_addr, client_port**  
  IP-адрес и порт клиента.

- **backend_start**  
  Время запуска данного бэкенда (когда клиент впервые подключился).

- **xact_start, query_start**  
  - *xact_start* — время начала текущей транзакции (если есть).  
  - *query_start* — время, когда началось выполнение текущего запроса.

- **state**  
  Состояние соединения:  
  - *active* — выполняется запрос;  
  - *idle* — простаивает (ожидает нового запроса);  
  - *idle in transaction* — в транзакции, но не выполняет запросов;  
  - *idle in transaction (aborted)* — транзакция прервана, но не завершена;  
  - *fastpath function call* — выполняется fast-path вызов (редко встречается);  
  - *disabled* — отключено (например, для управляемых соединений).

- **wait_event_type и wait_event**  
  Если PostgreSQL 9.6+ и выше, показывает тип ожидания (I/O, Lock, LWLock и т. д.) и конкретное событие ожидания. Помогает понимать, почему запрос «завис».

- **backend_type** (PostgreSQL 10+)  
  Тип бэкенда (например, client backend, autovacuum worker, logical replication worker и т. д.).

- **query**  
  Текст текущего запроса (или последний запрос, если процесс в состоянии idle).

Увидеть активные процессы и запросы:
```
SELECT pid, usename, application_name, state, query, query_start
FROM pg_stat_activity
WHERE state = \'active\';
```
Смотреть все процессы:
```
SELECT pid, usename, application_name, state, query, query_start
FROM pg_stat_activity;
```
Для поиска запросов, которые выполняются слишком долго, можно
использовать следующую команду:
```
SELECT pid, usename, application_name, state, query, query_start
FROM pg_stat_activity
WHERE state = \'active\'
AND now() - query_start \> interval \'5 minutes\';
```
Принудительное завершение запроса:

```
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE state = \'active\'
AND now() - query_start \> interval \'5 minutes\';
```
Эта команда завершит запросы, которые выполняются дольше 5 минут.

## **8. Логирование и анализ логов**

PostgreSQL логирует следующие типы событий:

-   **Запуск и остановка сервера.**

-   **Ошибки и предупреждения:** Например, ошибки подключения,
    синтаксические ошибки в запросах.

-   **Медленные запросы:** Если настроено логирование медленных
    запросов.

-   **Подключения и отключения клиентов.**

-   **Транзакции:** Начало, завершение, откат транзакций.

-   **Резервное копирование и восстановление.**

Системные логи Debian содержат события, связанные с работой операционной
системы:

-   **Запуск и остановка системных служб.**

-   **Ошибки ядра и драйверов.**

-   **Аутентификация и авторизация:** Например, вход пользователей,
    использование sudo.

-   **Работа сетевых служб.**

-   **Обновления системы и пакетов.**

-   **Аппаратные ошибки.**

![](vertopal_4f81362df5bd440b99b0b093da9050df/media/image14.png)

**Различие между логами PostgreSQL и системными логами**

| **Характеристика**   | **Логи PostgreSQL**                   | **Системные логи Debian**              |
|----------------------|---------------------------------------|----------------------------------------|
| **Расположение**     | /var/log/postgresql/                  | /var/log/                              |
| **Основные файлы**   | postgresql-17-main.log                | syslog, daemon.log, auth.log           |
| **Типы событий**     | Запросы, подключения, ошибки<br>СУБД  | Запуск служб, аутентификация,<br>ядро    |
| **Пример события**   | LOG: connection received              | systemd\[1\]: Started<br>PostgreSQL      |

